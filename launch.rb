#!/usr/bin/ruby

CONF_FILE = 'apps.conf'
STATUS_FILE = 'tmp/status'
YML_FILE = '/etc/thin/launch.yml'

PARAMS = {
  :shotgun => { :pidfile => 'tmp/pids/shotgun.pid',
                :logfile => 'log/shotgun.out',
                :stopcommand => 'kill #{PID}',  # This is not a typo. We manually interpolate
                :startcommand => 'nohup shotgun config.ru -s thin -o 0.0.0.0 -p 80 -E development > log/shotgun.out 2>&1 &'
              },
  :thin =>  { :pidfile => 'tmp/pids/thin.pid',
              :logfile => 'log/thin.log',
              :filesuffix => '',
              :group => 'root',
              :env => 'production',
              :stopcommand => '/etc/init.d/thin stop',
              :startcommand => '/etc/init.d/thin start'
            },
  :thindev => { :pidfile => 'tmp/pids/thin.80.pid',
                :logfile => 'log/thin.80.log',
                :filesuffix => '.80',
                :group => 'wheel',
                :env => 'development',
                :stopcommand => 'thin --config /etc/thin/launch.yml stop',
                :startcommand => 'thin --config /etc/thin/launch.yml start'
              }
}

def usage
  puts <<eom
launch one of more sinatra apps based on #{CONF_FILE} in current dir. usage:
  launch status: display status and configured apps
  launch stop: stops currently running apps
  launch start agent <app(s)>: start one of more apps
    agent: shotgun, thin, thindev
    app: specific app name or 'all' for all
eom
end

def showRunningApps(shouldBeRunning)
  if(File.exist?(STATUS_FILE))
    File.open(STATUS_FILE) do |f|
      status = f.read
      if(!shouldBeRunning)
        puts "Did thin/shotgun not stop cleanly? Launch seems to think apps are running"
      end
      puts "Launch says the currently running apps are: #{status}"
    end
  else
    if(shouldBeRunning)
      puts "Launch doesn't seem to think it launched any apps"
    end
  end
end

def status
  running = false
  PARAMS.each do |type, param|
    pid = nil
    if(File.exist?(param[:pidfile]))
      File.open(param[:pidfile]) do |f|
        pid = f.read
      end
    end
    if(pid != nil && pid != '')
      puts "Pidfile says that #{type} is running, pid #{pid}"
      # TODO: Verify from ps that it is indeed running
      running = true
      showRunningApps(true)
    end
  end
  if(!running)
    puts "Nothing is running"
    showRunningApps(false)
  end
end

def checkSudo
  user = `whoami`.chop
  if(user!='root')
    puts "ERROR: This script must be run as root for this command"
    exit(1)
  end
end

def stopApps(isRestart)
  checkSudo
  running = false
  PARAMS.each do |type, param|
    pid = nil
    if(File.exist?(param[:pidfile]))
      File.open(param[:pidfile]) do |f|
        pid = f.read
      end
    end
    if(pid != nil && pid != '')
      puts "Pidfile says that #{type} is running, pid #{pid}"
      # TODO: Verify from ps that it is indeed running
      running = true
      command = param[:stopcommand].sub(/\#\{PID\}/, pid)
      `#{command}`
      sleep 3
      File.delete(param[:pidfile]) if File.exist?(param[:pidfile])
      File.delete(STATUS_FILE) if File.exist?(STATUS_FILE)
      if(isRestart)
        puts "#{type} stopped."
      else
        puts "*******************"
        puts "#{type} stopped, tail:"
        puts "*******************"
        puts `tail #{param[:logfile]}`
      end
    end
  end
  if(!running && !isRestart)
    puts "ERROR: Nothing is running"
    showRunningApps(false)
    exit(1)
  end
end

def getAppsFromConf
  apps = []
  File.open(CONF_FILE) do |f|
    while(!f.eof) do
      line = f.readline.sub(/#.*/, '')
      if((line =~ /\S/) != nil)
        if((line =~ /\s*(\S+)\s+(\S+)\s+(\S+)\s+(.+)/) == nil)
          puts "ERROR: While parsing #{CONF_FILE} near #{line}"
          exit(1)
        end
        appName = $1.downcase
        if(appName == 'all')
          puts "ERROR: While parsing #{CONF_FILE}: App name cannot be 'all'"
          exit(1)
        end
        app = {:name => appName, :path => $2, :class => $3, :patterns => $4.split(/\s+/)}
        apps.push(app)
      end
    end
  end
  apps
end

def generateConfigRu(subjects)
  File.open('config.ru', 'w') do |ru|
    ru.write(<<eom
# THIS FILE WAS AUTOGENERATED BY launch.rb

require 'sinatra'
require 'sinatra/base'
require './helpers'

eom
    )
    all = subjects.include?('all')
    allApps = getAppsFromConf
    appsToRun = []
    allApps.each do |app|
      if(all || subjects.include?(app[:name]))
        appsToRun.push(app)
      end
    end
    if(appsToRun.count==1)
      app = appsToRun[0]
      ru.write("\nrequire '#{app[:path]}'\n\n")
      ru.write("run #{app[:class]}.new\n")
    else
      ru.write("$LOAD_PATH << './lib'\n")
      ru.write("require 'rack-stack'\n\n")
      appsToRun.each do |app|
        ru.write("require '#{app[:path]}'\n")
      end
      ru.write("\nrack_stack = RackStack.app do\n")
      appsToRun.each do |app|
        app[:patterns].each do |pattern|
          ru.write("  run #{app[:class]}.new, :when => {:host => /#{pattern}/}\n")
        end
      end
      ru.write("end\n\n")
      ru.write("run rack_stack\n")
    end
    appsToRun
  end
end

def ensureYmlExists(agent)
  # TODO: This only happens once so we're assuming that we will never run thin and thindev on the same machine
  param = PARAMS[:"#{agent}"]
  logfile = param[:logfile].sub(param[:filesuffix], '')
  pidfile = param[:pidfile].sub(param[:filesuffix], '')
  if(!File.exist?(YML_FILE))
    File.open(YML_FILE, "w") do |f|
      f.write(<<eom
--- 
user: root
group: #{param[:group]}
chdir: #{Dir.pwd}
log: #{logfile}
environment: #{param[:env]}
address: 0.0.0.0
port: 80
pid: #{pidfile}
timeout: 30
wait: 30
max_conns: 1024
require: []
max_persistent_conns: 512
servers: 1
threaded: true
daemonize: true
eom
      )   
    end
    puts "Generated #{YML_FILE} file"
  end
end

def ensureFoldersExist
  Dir.mkdir("log") unless(File.exist?("log"))
  Dir.mkdir("tmp") unless(File.exist?("tmp"))
  Dir.mkdir("tmp/pids") unless(File.exist?("tmp/pids"))
end

def generateStatusFile(apps)
  File.open(STATUS_FILE, "w") do |f|
    apps.each do |app|
      f.write(app[:name]+" ")
    end
  end
end

def startApps(agent, subjects)
  checkSudo
  stopApps(true)
  apps = generateConfigRu(subjects)
  puts "Generated config.ru with #{apps.count} app#{apps.count==1?'':'s'}"
  ensureFoldersExist
  generateStatusFile(apps)
 
  # TODO: Encapsulate this inside PARAMS
  if(agent=='thin' || agent=='thindev')
    ensureYmlExists(agent)
  end
  param = PARAMS[:"#{agent}"]
  File.delete(param[:logfile]) if File.exist?(param[:logfile])
  command = param[:startcommand]
  `#{command}`
  puts "Launched #{agent}... waiting for pid"
  sleep 3

  # TODO: Encapsulate this inside PARAMS
  if(agent=='shotgun')  
    ps = `ps -A`
    if((ps =~ /(\d+)\s+\S+\s+\S+\s+\S+ruby\s+\S+shotgun\s+config\.ru/) != nil)
      pid = $1
      File.open(param[:pidfile], "w") do |f|
        f.write(pid)
      end
    end
  end
  pid = nil
  if(File.exist?(param[:pidfile]))
    File.open(param[:pidfile]) do |f|
      pid = f.read
    end
  end
  if(pid==nil || pid=='')
    puts "ERROR: There was a problem launching #{agent}. Logfile:"
    puts `cat #{param[:logfile]}`
    exit(1)
  else
    puts "************************"
    puts "#{agent} running, PID #{pid}"
    puts "************************"
    puts `cat #{param[:logfile]}`
  end
end

if(ARGV.count==0)
  usage
  exit(1)
end
command = ARGV[0].downcase
if(command == 'status')
  status
  exit(0)
end
if(command == 'stop')
  stopApps(false)
  exit(0)
end
if(command == 'start')
  if(ARGV.count<3)
    usage
    exit(1)
  end
  agent = ARGV[1].downcase
  subjects = ARGV[2, ARGV.count-1]
  startApps(agent, subjects)
  exit(0)
end
usage
exit(1)
